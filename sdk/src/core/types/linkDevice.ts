import type { ActionResult } from './tatchi';
import type { AfterCall, DeviceLinkingSSEEvent, EventCallback } from './sdkSentEvents';
import { DeviceLinkingPhase } from './sdkSentEvents';
import { AccountId } from './accountIds';
import { SignedTransaction } from '../NearClient';
import { WebAuthnRegistrationCredential } from '.';
import type { ConfirmationConfig } from './signer-worker';

export { DeviceLinkingPhase } from './sdkSentEvents';

// === DEVICE LINKING TYPES ===
export interface DeviceLinkingQRData {
  /**
   * Opaque linking session identifier (generated by Device2).
   * When present, Device1 can "claim" the session on the relay so Device2 can
   * discover the target account without on-chain polling.
   */
  sessionId?: string;
  accountId?: AccountId; // Optional - Device2 discovers this from relay claim
  /**
   * Device2 ephemeral public key that Device1 should add to the account.
   */
  device2PublicKey?: string;
  timestamp: number;
  version: string; // For future compatibility
}

export interface DeviceLinkingSession {
  sessionId?: string;
  accountId: AccountId | null; // Null until discovered from contract logs (Option F) or provided upfront (Option E)
  deviceNumber?: number; // Device number assigned by Device1 for device linking
  nearPublicKey: string;
  credential: WebAuthnRegistrationCredential | null; // Null for Option F until real account discovered
  phase: DeviceLinkingPhase;
  createdAt: number;
  expiresAt: number;
  tempPrivateKey?: string; // For Option F flow - temporary private key before replacement
}

export interface LinkDeviceResult extends ActionResult {
  /** Public key added on Device1 (ephemeral key for device linking). */
  device2PublicKey: string;
  transactionId?: string;
  fundingAmount: string;
  linkedToAccount?: string; // The account ID that the device key was added to
}

export class DeviceLinkingError extends Error {
  constructor(
    message: string,
    public code: DeviceLinkingErrorCode,
    public phase: 'generation' | 'authorization' | 'registration'
  ) {
    super(message);
  }
}

export enum DeviceLinkingErrorCode {
  INVALID_QR_DATA = 'INVALID_QR_DATA',
  ACCOUNT_NOT_OWNED = 'ACCOUNT_NOT_OWNED',
  AUTHORIZATION_TIMEOUT = 'AUTHORIZATION_TIMEOUT',
  INSUFFICIENT_BALANCE = 'INSUFFICIENT_BALANCE',
  REGISTRATION_FAILED = 'REGISTRATION_FAILED',
  SESSION_EXPIRED = 'SESSION_EXPIRED'
}

export type StartDevice2LinkingFlowArgs = {
  ui?: 'modal' | 'inline';
  /**
   * Optional accountId for immediate completion on Device2.
   * When omitted, Device2 discovers the account via relay claim after Device1 adds the key.
   */
  accountId?: AccountId;
  /**
   * Optional preferred device number for the new passkey credential (1-indexed).
   * When omitted, device2 will attempt `2` and auto-increment on duplicate.
   */
  deviceNumber?: number;
  /**
   * Whether to derive and add a local signer key on device2 after linking completes.
   * Defaults to true.
   */
  localSignerEnabled?: boolean;
} & StartDeviceLinkingOptionsDevice2;

export interface StartDevice2LinkingFlowResults {
  qrData: DeviceLinkingQRData;
  qrCodeDataURL: string;
}

export interface StartDeviceLinkingOptionsDevice2 {
  cameraId?: string;
  options?: {
    onEvent?: EventCallback<DeviceLinkingSSEEvent>;
    onError?: (error: Error) => void;
    afterCall?: AfterCall<any>;
    confirmationConfig?: Partial<ConfirmationConfig>;
    confirmerText?: { title?: string; body?: string };
  };
}

export interface ScanAndLinkDeviceOptionsDevice1 {
  fundingAmount: string;
  onEvent?: EventCallback<DeviceLinkingSSEEvent>;
  onError?: (error: Error) => void;
  afterCall?: AfterCall<any>;
  confirmationConfig?: Partial<ConfirmationConfig>;
  confirmerText?: { title?: string; body?: string };
}
